<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>2. Concepts</TITLE>
<META NAME="description" CONTENT="2. Concepts">
<META NAME="keywords" CONTENT="usersguide">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="usersguide.css">
<LINK REL="next" HREF="node4.html">
<LINK REL="previous" HREF="node2.html">
<LINK REL="up" HREF="usersguide.html">
<LINK REL="next" HREF="node4.html">
</HEAD>
<BODY >
<!--Navigation Panel-->
<A NAME="tex2html127"
 HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html123"
 HREF="usersguide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html117"
 HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html125"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html126"
 HREF="node9.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html128"
 HREF="node4.html">3. Starting SCIRun</A>
<B> Up:</B> <A NAME="tex2html124"
 HREF="usersguide.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html118"
 HREF="node2.html">1. Introduction</A>
<BR>
<BR>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"><strong>Subsections</strong></A>
<UL>
<LI><A NAME="tex2html129"
 HREF="node3.html#SECTION00031000000000000000">2.1 Traditional problem solving methods</A>
<LI><A NAME="tex2html130"
 HREF="node3.html#SECTION00032000000000000000">2.2 Integrated problem solving and computational
steering</A>
<LI><A NAME="tex2html131"
 HREF="node3.html#SECTION00033000000000000000">2.3 <EM>SCIRun</EM> modules and networks</A>
<LI><A NAME="tex2html132"
 HREF="node3.html#SECTION00034000000000000000">2.4 Links to third party software</A>
<LI><A NAME="tex2html133"
 HREF="node3.html#SECTION00035000000000000000">2.5 Extensibility</A>
<LI><A NAME="tex2html134"
 HREF="node3.html#SECTION00036000000000000000">2.6 Detachable interface</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A NAME="SECTION00030000000000000000">&#160;</A>
<A NAME="sec:concepts">&#160;</A> 
<A NAME="526">&#160;</A>
<BR>
2. Concepts
</H1>

<P> This section explains the design philosophy and goals of integrated problem 
  solving environments and how <EM>BioPSE</EM> embodies some of these ideas. 
<P>

<H2><A NAME="SECTION00031000000000000000"> 2.1 Traditional Problem Solving Methods</A> 
</H2>

<P> Traditional methods for solving bioelectric field problems use multiple, non-integrated 
  computer programs. For example, a scientist using a computer simulation to examine 
  the effect of electrode patch placement on transcardiac current density in the 
  design of a cardiac implantable defibrillator[<A
 HREF="node8.html#CRJ:Sch95b">1</A>] would require geometric modeling, numerical 
  simulation, and scientific visualization tools to complete the task. The user 
  might need two different programs; one to define the thoracic surfaces from 
  medical images and another to create a discrete mesh of the volume contained 
  within the surfaces[<A
 HREF="node8.html#CRJ:Sch93b">2</A>]. Another application, like Matlab, computes 
  a finite element simulation of the electric current distribution from the defibrillation 
  electrodes through the thoracic volume[<A
 HREF="node8.html#RSM:And93">3</A>]. Another approach might be to write a Fortran 
  program using a public domain numerical library such as LAPACK <A NAME="533">&#160;</A>. 
  A scientific visualization package (such as those described in[<A
 HREF="node8.html#RSM:All91">4</A>]) would be required to see the package. between 
  steps, it would be necessary to save the output of one program in a format that 
  the next in the sequence could read--this might necessitate separate file format 
  conversion utilities. To find the optimal location, shape, and size parameters 
  for the defibrillating electrode, the scientist would have to go back to the 
  geometric modeling package, change the necessary parameters, manually re-run 
  all of the subsequent steps to see how the new electrode configuration affects 
  the current density distribution, and then manually iterate. The manual intervention 
  required to drive this process is both tedious and time consuming. 
<P> A more efficient scenario would be one in which the user could define an appropriate 
  set of parameters for a given simulation, initiate a sequence of runs to examine 
  each of them and save the results for subsequent examinations. The complete 
  execution of the sequence might require hours or even days, but the user would 
  be free during that time to perform other tasks. This process is similar to 
  the ``what if?'' analysis that modern spreadsheet programs offer for much simpler 
  problems. 
<P> In our example of the defibrillation simulation, the scientist could select 
  various locations and orientations for the defibrillation electrodes, choose 
  values for the other parameters of the simulation (<EM>e.g.,</EM> the number 
  of nodes in the finite element model, the boundary conditions, the error tolerance 
  for convergence, and the evaluation criteria), and leave the simulations to 
  run as long as necessary. Viewing the results might be as simple as watching 
  the animation produced by the simulation, or scanning other defibrillation quality 
  indices such as maximum and minimum current density magnitude, or current density 
  histograms from the heart. <i>Batch processing</i> is the automated execution 
  process, whereby the user selects all of the parameters in advance and does 
  not control the intra-/inter-package execution. A primary benefit of batch processing 
  it that it allows the scientist to utilize computational resources without the 
  need to continuously guide the process. However, with most available computer 
  programs, execution cannot be automated. That is, the package cannot be run 
  without regular user intervention during execution. This constraint makes it 
  difficult or impossible to run multiple computational jobs automatically, leaving 
  the user with the task of manually initiating and controlling each step of the 
  process. 
<P>

<H2><A NAME="SECTION00032000000000000000">&#160;</A> 
<A NAME="sec:con-steering">&#160;</A>
<BR>
  2.2 Integrated Problem Solving and Computational Steering </H2> 

<P> The goal of integrated problem solving environments--and specifically of <EM>SCIRun</EM> 
  and <EM>BioPSE</EM>--is to integrate all of the steps described in the previous 
  example as components of a single, unified, extensible problem solving environment 
  (PSE)<A NAME="541">&#160;</A>. The functionality that results will include the 
  ability to manage each step in a sequential computing process, and to create 
  batch processes that execute repeated simulations. The ability to intervene 
  and control execution anywhere and at any time in the chain during its execution 
  are the functions that set<EM>SCIRun</EM> and <EM>BioPSE</EM> apart from most 
  integrated software environments.<i>Computational steering</i> is this ability 
  to control a computer program during execution. 
<P> To provide a non-technical analogy, adding computational steering to a software 
  environment is similar to occasionally switching tracks while riding a train. 
  A train passenger can get on the train and automatically get to a new destination, 
  leaving all the details of the individual actions to the rail system machinery 
  and staff, because the route and the destination are fixed. Steering would permit 
  each passenger to request a new route, different stops and even a different 
  destination. Passengers would be able to make these decisions at any time during 
  the trip. In the more rigorous example of the defibrillation simulation, computational 
  steering allows a scientist to interactively change parameters and settings 
  as the simulation executes, both as a single run or in batch mode. Steering 
  interventions might include adjusting electrode locations to stay within anatomically 
  reasonable bounds or refining the geometric model resolution in order to balance 
  accuracy and execution time. 
<P>
To achieve integration within the elements of <EM>SCIRun</EM> and <EM>BioPSE</EM>, data 
flows directly from one processing step to the next, without ever being
diverted to a disk file or leaving the program.  Output from any step 
are available as inputs to dependent steps.  The underlying paradigm of
<EM>SCIRun</EM> is of data flowing between modules that each perform some
operation.  Integration between modules guarantees that upon completion of
their tasks, upstream modules pass their data to downstream modules,
thereby forcing the downstream modules to execute in response.  In our
example, this means that the scientist may alter electrode locations at any
time, thus initiating a sequence of all the necessary steps to recompute
the simulation with the new configuration.  The modification of the
geometric model, finite element calculation, and visualization all proceed
automatically and in the proper sequence, all managed by <EM>SCIRun</EM>.  This
combination of steering and component integration allows the scientist
to spontaneously explore a problem.  

<P>
While computational steering is still a young field in computer science,
there are a number of examples of such systems (besides <EM>SCIRun</EM>) described in
the literature.  Burnett[<A
 HREF="node8.html#MM:Bur94">5</A>], and Vetter and
Schwan[<A
 HREF="node8.html#MM:Vet96">6</A>] give overviews of existing computational steering
system.  Several notable examples include CUMULVS[<A
 HREF="node8.html#MM:Gei96">7</A>,<A
 HREF="node8.html#MM:Koh97">8</A>],
<A NAME="553">&#160;</A> Progress[<A
 HREF="node8.html#MM:Vet95">9</A>], <A NAME="555">&#160;</A> and
Magellan[<A
 HREF="node8.html#MM:Vet97a">10</A>] <A NAME="557">&#160;</A>.

<P>

<blockquote>
  <H3><A NAME="SECTION00032100000000000000"> 2.2.1 <EM>SCIRun</EM> Versus <EM>BioPSE</EM></A> 
  </H3>
</blockquote>
<P> It is important to understand the software included in this package within 
  the hierarchy of computational problem solving environments developed at the 
  SCI Institute. From an historical perspective, <EM>SCIRun</EM>, which we started 
  developing in 1992, was the original implementation of the computational framework[<A
 HREF="node8.html#CRJ:Joh94c">11</A>,<A
 HREF="node8.html#RSM:Par95">12</A>,<A
 HREF="node8.html#RSM:Par95b">13</A>,<A
 HREF="node8.html#RSM:Par97">14</A>,<A
 HREF="node8.html#RSM:Par97b">15</A>,<A
 HREF="node8.html#CRJ:Parker99b">16</A>]. Since then, <EM>SCIRun</EM> and its 
  computational workbench infrastructure have originated many significant application-specific 
  projects. Two major examples are the DOE sponsored Uintah system [<A
 HREF="node8.html#RSM:Dav2000">17</A>] and the NIH sponsored <EM>BioPSE</EM> system. 
  The target applications of the Uintah project are combustion, computational 
  fluid dynamics, and mechanical modeling implemented on large-scale, distributed, 
  shared memory architectures. The goal of the <EM>BioPSE</EM> project is to create 
  software for geometric modeling, simulation, and visualization for solving bioelectric 
  field problems. An important secondary goal of the <EM>SCIRun</EM> system is 
  to make source code for these problem solving environments publicly available 
  to the scientific community. 
<P> To realize these two significant projects, the <EM>SCIRun</EM> infrastructure 
  itself has required significant reorganization, extension, and enhancement. 
  Even with these recent changes, <EM>SCIRun</EM> remains both the core infrastructure 
  for our problem solving environments and the name that refers to the entire 
  ensemble of software. Thus, a user may install and operate the core <EM>SCIRun</EM> 
  software and also augment its functionality with one or more "packages" such 
  as <EM>BioPSE</EM>. We anticipate that this collection of packages will grow 
  as the <EM>SCIRun</EM> infrastructure becomes available to scientists and engineers 
  of all disciplines. 
<P> In addition to the major projects that have both leveraged and advanced <EM>SCIRun</EM>, 
  exist a number of smaller packages that can extend <EM>SCIRun</EM>'s utility. 
  Examples include the Teem package for raster data processing, the NetSolve package 
  for linear algebra subroutines (developed by researchers at the University of 
  Tennessee and Knoxville) and a communications interface recently introduced 
  by SCI to the Matlab program. <EM>SCIRun</EM> leverages the strengths of third 
  party tools through various forms of software wrappers or interfaces--links 
  we refer to as "bridges." 
<P> There are also instances in which a tighter level of integration than a bridge 
  between <EM>SCIRun</EM> and third-party software is necessary. One example is 
  the addition of mpeg support for capturing animations from the <EM>SCIRun</EM> 
  Viewer module, for which we use the Berkeley and Alex Knowles' mpeg encoding 
  tools. Another example is the set of image generation and manipulation tools 
  from Peter Haeberli titled Libimage. To indicate whether or not such tools are 
  available, the configure scripts for <EM>SCIRun</EM> contain optional control 
  flags. 
<P> At the SCI Insititute, we believe that a robust infrastructure combined with 
  modular extensibility through packages and third-party libraries allows <EM>SCIRun</EM> 
  to grow, adapting to the user's changing needs and opportunities. 
<P> In this guide, the usage of the two terms, <EM>SCIRun</EM> and <EM>BioPSE</EM>. 
  <EM>SCIRun</EM> will be used consistently, typically referring to some feature 
  that is common to the core functionality of the system, and to all of the problem 
  solving environment applications packages. <EM>BioPSE</EM> will refer to specific 
  elements of the bioelectric field problem solving environment. 
<P>

<H2><A NAME="SECTION00033000000000000000">&#160;</A>
<A NAME="sec:con-modules">&#160;</A>
<BR>
  2.3 <EM>SCIRun</EM> Modules and Networks </H2> 

<P>
<BR>
<DIV ALIGN="CENTER"><A NAME="fig:conc-module">&#160;</A><A NAME="671">&#160;</A>
<TABLE WIDTH="50%">
<CAPTION><STRONG>Figure 1:</STRONG>
Example of a <EM>SCIRun</EM> module</CAPTION>
<TR><TD><IMG
  WIDTH="766" ALIGN="TOP"
 SRC="../figures/biopse-modmap.gif"
 ALT="module"></TD></TR>
</TABLE>
</DIV>
<BR>
<P> A module is the functional unit of a dataflow environment. <A NAME="592">&#160;</A>. 
  Figure&nbsp;<A HREF="node3.html#fig:conc-module">1</A> contains a generic <EM>SCIRun</EM> 
  module, with a User Interface (UI) button for graphically accessing the module's 
  parameters; input and output ports for receiving and sending data, respectively. 
  A simple data flow network appears on the right. Data passes through the output 
  port of the top module, through the data pipe, and into the input port of the 
  bottom module. The User Interface enables the selection of a desired isochrone 
  surface. 
<P> Modules may contain other elements, but they will all have at least one input 
  or one output port. File readers would be examples of a module with only an 
  output port. The <A NAME="tex2html12"
 HREF="viewer.html"><EM>Viewer</EM></A> module contains only input ports because 
  it receives information and the output is a visualization. For a more detailed 
  description of modules and how to control them, see <A HREF="node5.html#sec:workwithnets"><EM>Working 
  with Networks</EM></A>. The most important goal at this stage is to appreciate 
  the concept of a module and the dataflow that links one module to another. 
<P>
A network diagram <A NAME="599">&#160;</A> describes the way data flows
through <EM>SCIRun</EM> and is the main means of user interaction with the overall
action of the program.  The network essentially defines the basic function of
the program; without a network, <EM>SCIRun</EM> and <EM>BioPSE</EM> are just a set of tools
sitting in a chest.  By joining the modules into a network, the tools
become a functioning program that does whatever the network tells it to.
Once again, the important thing to appreciate is what the network is
conceptually; for the details, see <A HREF="node5.html#sec:workwithnets"><EM>Working with
Networks</EM></A>. 

<P>

<H2><A NAME="SECTION00034000000000000000">&#160;</A>
<A NAME="sec:con-links">&#160;</A>
<BR>
  2.4 Links to Third Party Software </H2> 

<P> <EM>SCIRun</EM> works together with software from third party sources in several 
  ways. If you have installed <EM>SCIRun</EM> and <EM>BioPSE</EM> yourself, you 
  will have seen the need for some third party software libraries that are required 
  for basic functionality. This type of third party software is largely invisible 
  to the user of <EM>SCIRun</EM> or <EM>BioPSE</EM>, at least until something 
  breaks. Perhaps the most evident is the <A NAME="tex2html13"
 HREF="http://www.tcltk.com/">TCL/Tk</A> <A NAME="615">&#160;</A> library, which 
  <EM>SCIRun</EM> uses to create the network editor and the icons for the modules 
  and data pipes. In fact, <EM>SCIRun</EM> is actually a large TCL script that 
  calls a lot of specialized C++ code to do all the hard work. 
<P>The interaction between programs written in FORTRAN <A NAME="618">&#160;</A> 
  or <A NAME="tex2html14"
 HREF="http://www.mathworks.com/products/matlab/">Matlab</A> and <EM>SCIRun</EM> 
  are far more interesting. One of the goals of the <EM>BioPSE</EM> project was 
  to develop support for such external code, including FORTRAN, C, Matlab, and 
  IDL. This first version of <EM>BioPSE</EM> has support for Matlab and one example 
  of wrapping existing FORTRAN code into a <EM>SCIRun</EM> module. <A NAME="625">&#160;</A> 
<P>

<blockquote>
  <H3><A NAME="SECTION00034100000000000000">&#160;</A> <A NAME="sec:concept-matlab">&#160;</A> 
    <BR>
    2.4.1 <EM>SCIRun</EM>/Matlab Interface </H3>
</blockquote>
<P> The interface (based on Berkeley sockets) between <EM>SCIRun</EM> and Matlab 
  provides a pathway to send matrix data objects from <EM>SCIRun</EM> to Matlab, 
  and then accept the result of some Matlab computations. At present, this arrangement 
  requires that a Matlab script exist that performs the desired operations. <EM>SCIRun</EM> 
  sends the input data to an existing process running Matlab, which serves as 
  a compute engine, performs the steps described in the script, and then returns 
  data to <EM>SCIRun</EM> for further processing or display. The Matlab process 
  can even run on a separate computer connected via a network, which helps to 
  distribute the load as well as to resolve potential licensing conflicts with 
  Matlab. 
<P> The underlying mechanism for this communication is a socket interface consisting 
  of two <EM>SCIRun</EM> Modules, <TT>MatrixSend</TT> and <TT>MatrixReceive</TT>, 
  and a Matlab ``transport'' routine. Both the <EM>SCIRun</EM> and the Matlab 
  process know about each other's whereabouts (in the form hostname:port) and 
  use a client-to-client communication model, so that synchronization between 
  processes is manual. For example, the <EM>SCIRun</EM> <TT>MatrixSend</TT> module 
  sends the matrix to a socket at which a Matlab script is listening. The script 
  then receives the matrix, performs the calculations in Matlab and sends the 
  results to a socket where <TT>MatrixReceive</TT> module is listening. <EM>SCIRun</EM>then 
  carries out further calculations and displays the results. 
<P>

<H3><A NAME="SECTION00034200000000000000"> 2.4.2 Links to GENESIS</A> </H3>
<P> <A NAME="tex2html15"
 HREF="http://www.bbb.caltech.edu/GENESIS/genesis.html">GENESIS</A> (short for 
  GEneral NEural SImulation System) is a general purpose simulation platform, 
  developed to support the simulation of neural systems ranging from complex models 
  of single neurons,to to simulations of large networks made up of more abstract 
  neuronal components. GENESIS has provided the basis for laboratory courses in 
  neural simulation at both Caltech and the Marine Biological Laboratory in Woods 
  Hole, MA, as well as many other institutions. 
<P> We have created a bridge between <EM>SCIRun</EM> and GENESIS, making it possible 
  to use the output of a GENESIS simulation as the input for either a visualization 
  or a subsequent simulation within <EM>BioPSE</EM>. The mechanism for this bridge 
  is a database that is accessible via SQL queries. We created code for GENESIS 
  that writes the output of the simulation into the database and corresponding 
  functions for <EM>SCIRun</EM> that read this information from the same database. 
  The details of this mechanism are currently in development. For details, please 
  contact Chris Butson <A NAME="tex2html16"
 HREF="mailto:Christopher.Butson@m.cc.utah.edu">Christopher.Butson@m.cc.utah.edu</A>. 
<P>

<H2><A NAME="SECTION00035000000000000000">&#160;</A>
<A NAME="sec:con-extend">&#160;</A>
<BR>
2.5 Extensibility
</H2> 

<P> <EM>SCIRun</EM> is an extensible <A NAME="650">&#160;</A> problem solving 
  environment. This is true since no one except the user really limits the different 
  ways of connecting modules and creating new applications. This is also more 
  generally since <EM>SCIRun</EM> is designed for users who can create their own 
  new modules. To support new modules, we have developed the <EM>Module maker</EM> 
  application, described in The <A NAME="tex2html17"
 HREF="http://modulemaker">Module Maker Manual</A>. 
<P> With the release of <EM>SCIRun</EM>, we anticipate that users all over the 
  world will create new modules, and we encourage them to contribute modules to 
  a repository on the <EM>BioPSE</EM> web site <A NAME="674">&#160;</A> (<A NAME="tex2html18"
 HREF="http://www.sci.utah.edu/ncrr/software/biopse.html">www.sci.utah.edu/ncrr/software/biopse.html</A>. 
  We will review submissions to this collection of modules, adopt and then test 
  generally useful ones to include in subsequent releases of <EM>BioPSE</EM>. 
  Future releases will also include more extensive tools for both building modules 
  and wrapping existing codes within <EM>SCIRun</EM> module wrappers, maximizing 
  the user's intellectual investment in legacy code. 
<P>

<H2><A NAME="SECTION00036000000000000000">&#160;</A>
<A NAME="sec:con-detach">&#160;</A> 
<A NAME="664">&#160;</A>
<BR>
  2.6 Detachable Interface </H2>

<P> The deatchable interface is a strategy seen in a few PSEs currently under 
  development and an integral part of <EM>SCIRun</EM>. Rather than having a fixed 
  link between a user interface and the underlying application, a detachable interface 
  can be separated from the application, in which case the application becomes 
  unsteerable. The advantage, however, lies in the ability to now re-attach an 
  interface to a running application, thus re-enable steering. The re-attached 
  interface need not be from the same physical computer from which the application 
  was started, instead it may come from a remote computer via a network, or from 
  another user on the same computer. The re-attached interface may not be an interactive 
  widget at all, but a set of commands executed from a script. This additional 
  strength permits complete remote control of the application, thus, becomes a 
  flexible blend of interactive and almost unlimited batch control. CUMULVS <A NAME="666">&#160;</A> 
  is one example of such a system and uses its detachable interface to allow collaboration 
  between scientists working remotely, with viewing systems that can attach or 
  detach from the running simulation. 
<P> The first release of <EM>SCIRun</EM> will not include any of the detachable 
  interface support, but SCI plans to add this within six months of the first 
  release. 
<P>

<HR>
<!--Navigation Panel-->
<A NAME="tex2html127"
 HREF="node4.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html123"
 HREF="usersguide.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html117"
 HREF="node2.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html125"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html126"
 HREF="node9.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> 
<BR>
<B> Next:</B> <A NAME="tex2html128"
 HREF="node4.html">3. Starting SCIRun</A>
<B> Up:</B> <A NAME="tex2html124"
 HREF="usersguide.html">No Title</A>
<B> Previous:</B> <A NAME="tex2html118"
 HREF="node2.html">1. Introduction</A>
<!--End of Navigation Panel-->
<ADDRESS>
<I>Rob MacLeod</I>
<BR><I>2001-05-30</I>
</ADDRESS>
</BODY>
</HTML>
