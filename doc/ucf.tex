\section{Using Uintah} \label{Sec:UCF}

Several executable programs have been developed using the Uintah
Computational Framework (UCF).  The primary code that drives the
components implemented in Uintah is called \tt sus
\normalfont, which stands for Standalone Uintah Simulation.  The existing
components were originally developed to solve a complex fluid structure problem
involving a container filled with an explosive enveloped in a fire.
These components model the fire and the subsequent heat transfer to the
container followed by the resultant container deformation and ultimate
rupture due to the ignition and burning of the explosive material.
Although Uintah was developed originally to solve this complicated
multi-physics problem, the general nature of the algorithms and the
framework have allowed researchers to use the code to investigate a
wide range of problems.
%  The framework is general purpose enough to
%allow for the implementation of FIX ME

This code leverages the task based parallelism inherent in the UCF to
implement several time stepping algorithms for structural mechanics (MPM),
fluid dynamics (Arches and ICE) , and fluid structure interactions
(MPMICE and MPMArches).  What follows is a description of using
\tt sus \normalfont within the realm of these existing components.

%__________________________________
\subsection{Mechanics of Running sus}
 - Explain how to run on multiple processors\\
 - what do the different command line options mean\\
 - how to restart an uda\\

For single processor simulations, the \tt sus \normalfont excutable
(Standalone Uintah Simulation) is run from the command line prompt
like this:
\begin{Verbatim}[fontsize=\footnotesize]
  
  sus <input.ups>

\end{Verbatim}
where \tt input.ups \normalfont is an xml formatted input file.  The Uintah
software release contains numerous example input files located in the
src/StandAlone/inputs directory.

For multiprocessor runs, the user generally uses \tt mpirun \normalfont to launch
the code.  Depending on the environment, batch scheduler, launch
scripts, etc, \tt mpirun \normalfont may or may not be used.  However, in general,
something like the following is used:
\begin{Verbatim}[fontsize=\footnotesize]

  mpirun -np num_processors sus -mpi input.ups

\end{Verbatim}
\tt num\_processors \normalfont is the number of processors that will be used.  The
input file must contain a patch layout that has at least the same
number (or greater) of patches as processors specified by a number
following the -np option shown above.

In addition, the \tt -mpi \normalfont is optional but often times necessary if the mpi
environment is not automatically detected from within the sus
executable.
 
%__________________________________
\subsection{Time Related Variables} \label{Sec:TimeRelatedVariables}
Uintah components are time dependent codes.  As such, one of the first entries
in each input file describes the timestepping parameters.  An input file
segment is given below that encompasses all of the possible parameters.
Most are self-explanatory, and not all are required,
(e.g \tt <max\_Timestep>,
<max\_delt\_increase>, <end\_on\_max\_time\_exactly> \normalfont and
\tt <delt\_init> \normalfont are all optional).
\tt <timestep\_multiplier> \normalfont serves
as a CFL number, that is, a number, usually less than 1.0, that is used to
moderate the timestep automatically calculated by the individual components. 

\begin{Verbatim}[fontsize=\footnotesize]
<Time>
    <maxTime>            1.0         </maxTime>
    <initTime>           0.0         </initTime>
    <delt_min>           0.0         </delt_min>
    <delt_max>           1.0         </delt_max>
    <delt_init>          1.0e-9      </delt_init>
    <max_delt_increase>  2.0         </max_delt_increase>
    <timestep_multiplier>1.0         </timestep_multiplier>
    <max_Timestep>       100         </max_Timestep>
    <end_on_max_time_exactly>true    </end_on_max_time_exactly>
</Time>
\end{Verbatim}
%
%__________________________________
\subsection{Data Archiver} \label{Sec:DataArchiver}
- variable labels\\
- checkpointing \\
- different options for specifying the output frequency\\
%
%__________________________________
\subsection{Geometry objects} \label{Sec:GeometryObjects}
- different objects available and how to specify them\\
- what is res \\
- operators, union, difference\\
- example of combining several geom\_objects\\

%__________________________________
\subsection{Boundary conditions}
- describe how to have a jet in the floor of the domain.
%
%__________________________________
\subsection{Grid specification} \label{Sec:Grid}
Explain how a grid is specified and what these tags mean

\begin{Verbatim}[fontsize=\footnotesize]
<Level>
    <Box label="1">
       <lower>        [0,0,0]          </lower>
       <upper>        [5,5,5]          </upper>
       <extraCells>   [1,1,1]          </extraCells>
       <patches>      [1,1,1]          </patches>
    </Box>
    <spacing>         [0.5,0.5,0.5]    </spacing>
</Level>
 \end{Verbatim}
%
%__________________________________
\subsection{Adapative Mesh Refinement}
- need to discuss the input options for the different regridders.\\
- How is a cell flagged as needing to be refined
%
%__________________________________
\subsection{load Balancer}
- to be filled in

%__________________________________
\subsection{UDA}

\subsubsection{UDA Directory Structure}

The UDA is a file/directory structure used to save Uintah simulation
data.  For the most part, the user need not concern him or herself
with the UDA layout, but it is a good idea to have a general feeling
for how the data is stored on disk...

%\subsubsubsection{UDA Naming}

Every time a simulation (sus) is run, a new UDA is created.  Sus uses
the <filebase> tag in the simulation input
(FIXME: link to [[Documentation/UsersGuide Input\_Files|.ups]]) file to name the UDA
directory (appending a version number).  If an UDA of that name
already exists, the next version number is used.  Additionally, a
symbolic link named ``disks.uda'' (is updated to and) will point to
the newest version of this simulations UDA.  Eg:

disks.uda.000
disks.uda.001
disks.uda.001 <- disks.uda

%\subsubsubsection{UDA Files}

Each UDA consists of a number of top level files, a checkpoints
subdirectory, and subdirectories for each saved timestep.  These files
include:

- \tt.dat\normalfont files contain global information about the simulation
(each line in the .dat files contains: simulation\_time value).
- The \tt checkpoints\normalfont directory contains a limited number of time
step data subdirectories that contain a complete snapshot of the
simulation (allowing for the simulation to be restarted from that
time).
- \tt input.xml\normalfont contains the original problem specification (the
.ups file).
- \tt index.xml\normalfont contains information on the actual simulation run.
- \tt t0000 FIXME number sign\normalfont contains data saved for that specific time step.  The
data saved is specified in .ups file and may be a very limited subset
of the full simulation data.

Example UDA file list:

CenterOfMassPosition.dat
CenterOfMassVelocity.dat
KineticEnergy.dat
StrainEnergy.dat
TotalMass.dat
checkpoints
index.xml
input.xml
t00001
t00057

%\subsubsection{Known Issues} 

Occasionally, due (most likely) to file system issues on large
clusters, some of the files in the UDA have been found to be corrupted
or nonexistent.  (There is error checking in the code to try to
prevent this.  We believe that either the OS/File system is
incorreclty returning error codes, or, more likely, that the files are
corrupted (due to file system issues) after the simulation is done.

%\subsubsection{Restarting} 

FIXME: discuss how to modify an input parameter before you restart an uda.

%__________________________________
\subsection{Visualization tools}

Visualization of Uintah data is currently possible using any of three
software packages.  These are SCIRun, VisIt and Manta.  Of these, SCIRun is
no longer supported, although legacy versions will continue to work.  The
VisIt package from LLNL is general purpose visualization software that offers
all of the usual capabilities for rendering scientific data.  It is still
developed and maintained by LLNL staff, and its interface to Uintah data is
supported by the Uintah team.  Manta offers volume rendering and particle
visualizaton based on parallel (shared memory) ray tracing techniques.
While the capabilities of Manta are more limited, it is a fast way to
interactively interrogate reasonably large datasets, provided the user has
access to a reasonable shared memory resource, (e.g. an 8 core desktop system).

\subsubsection{VisIt}

\subsubsection{Manta}

%__________________________________
\subsection{Data Extraction Tools}

Uintah offers a number of tools for accessing data stored in Uintah Data
Archives (``UDAs").  Because the format of Uintah data is specific to the 
framework, these tools allow a user to quickly extract data, which can then
either be postprocessed within that tool (simple modification of the source
code may be necessary), postprocessed with external software such as
Matlab or Octave, or simply plotted with, e.g. gnuplot.  These tools
are described below.

\subsubsection{puda}

\subsubsection{partextract}

\subsubsection{lineextract}

\subsubsection{timeextract}

\subsubsection{compare\_uda}

%__________________________________
\subsubsection{plotting tools}
- plotStats\\
- plotRegridder \\
- plotCPU\_usage \\
- plotComponents

%__________________________________
\subsection{Code}
-explain the basic directory structure of src
\begin{Verbatim}[fontsize=\footnotesize]
|-- CCA
|-- Components
|   |-- Angio
|   |-- Arches
|   |-- DataArchiver
|   |-- Examples
|   |-- ICE
|   |-- LoadBalancers
|   |-- MPM
|   |-- MPMArches
|   |-- MPMICE
|   |-- Models
|   |-- OnTheFlyAnalysis
|   |-- Parent
|   |-- PatchCombiner
|   |-- ProblemSpecification
|   |-- Regridder
|   |-- Schedulers
|   |-- SimulationController
|   |-- Solvers
|   |-- SpatialOps
|   `-- SwitchingCriteria
|-- Ports
|-- Core
|-- R_Tester
|-- StandAlone
|-- Teem
|-- VisIt
|-- build_scripts
|-- include
|-- orderAccuracy
|-- scripts
|-- tau
|-- testprograms
`-- tools
\end{Verbatim}
