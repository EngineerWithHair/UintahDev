\section{Using Uintah} \label{Sec:UCF}

Several executable programs have been developed using the Uintah
Computational Framework (UCF).  The primary code that drives the
components implemented in Uintah is called \tt sus \normalfont, which
stands for Standalone Uintah Simulation.  The existing components were
originally developed to solve a complex fluid structure problem
involving a container filled with an explosive enveloped in a fire.
These components model the fire and the subsequent heat transfer to
the container followed by the resultant container deformation and
ultimate rupture due to the ignition and burning of the explosive
material.  Although Uintah was developed originally to solve this
complicated multi-physics problem, the general nature of the
algorithms and the framework have allowed researchers to use the code
to investigate a wide range of problems.

This code leverages the task based parallelism inherent in the UCF to
implement several time stepping algorithms for structural mechanics (MPM),
fluid dynamics (Arches and ICE) , and fluid structure interactions
(MPMICE and MPMArches).  What follows is a description of using
\tt sus \normalfont within the realm of these existing components.

%__________________________________
\subsection{Mechanics of Running sus}
 - Explain how to run on multiple processors\\
 - what do the different command line options mean\\
 - how to restart an uda\\

For single processor simulations, the \tt sus \normalfont excutable
(Standalone Uintah Simulation) is run from the command line prompt
like this:
\begin{Verbatim}[fontsize=\footnotesize]
  
  sus <input.ups>

\end{Verbatim}
where \tt input.ups \normalfont is an xml formatted input file.  The
Uintah software release contains numerous example input files located
in the src/StandAlone/inputs directory.

For multiprocessor runs, the user generally uses \tt mpirun
\normalfont to launch the code.  Depending on the environment, batch
scheduler, launch scripts, etc, \tt mpirun \normalfont may or may not
be used.  However, in general, something like the following is used:
\begin{Verbatim}[fontsize=\footnotesize]

  mpirun -np num_processors sus -mpi input.ups

\end{Verbatim}

\tt num\_processors \normalfont is the number of processors that will
be used.  The input file must contain a patch layout that has at least
the same number (or greater) of patches as processors specified by a
number following the -np option shown above.

In addition, the \tt -mpi \normalfont is optional but often times
necessary if the mpi environment is not automatically detected from
within the sus executable.
 

\subsection{Input File Specification} \label{Sec:InputFileSpecification}

The Uintah framework uses xml input files to specify the various
parameters required in any simulation component.  The application
developer is free to use any tags to specify the data needed by the
simulation.  The essential tags that are required by Uintah include
the following:

\begin{verbatim}

	<Uintah_specification>

         <SimulationComponent>

	<Time>

	<DataArchiver>

	<Grid>

\end{verbatim}


Individual components have additional tags that specify properties,
algorithms, materials, etc. that are unique to that individual
components.  Within the individual sections on MPM, ICE, MPMICE,
Arches, and MPMArches, the individual tags will be explained more
fully.  

The sus executable verifies that the input file adheres to a consitent
specification and that all necessary tags are specified.  However, it
is up to the individual creating or modifying the input file to put in
physically reasonable set of consistent parameters.


\subsection{Simulation Components} \label{Sec:SimulationComponent}

The input file tag for SimulationComponent has the \em{type} attribute
that must be specified with either mpm, mpmice, ice, arches, or
mpmarches.  

\begin{verbatim}[fontsize=\footnotesize]

<SimulationComponent type = "mpm" />

\end{verbatim}



%__________________________________
\subsection{Time Related Variables} \label{Sec:TimeRelatedVariables}
Uintah components are time dependent codes.  As such, one of the first
entries in each input file describes the timestepping parameters.  An
input file segment is given below that encompasses all of the possible
parameters.  Most are self-explanatory, and not all are required, (e.g
\tt <max\_Timestep>, <max\_delt\_increase>,
<end\_on\_max\_time\_exactly> \normalfont and \tt <delt\_init>
\normalfont are all optional).  \tt <timestep\_multiplier> \normalfont
serves as a CFL number, that is, a number, usually less than 1.0, that
is used to moderate the timestep automatically calculated by the
individual components.

\begin{Verbatim}[fontsize=\footnotesize]
<Time>
    <maxTime>            1.0         </maxTime>
    <initTime>           0.0         </initTime>
    <delt_min>           0.0         </delt_min>
    <delt_max>           1.0         </delt_max>
    <delt_init>          1.0e-9      </delt_init>
    <max_delt_increase>  2.0         </max_delt_increase>
    <timestep_multiplier>1.0         </timestep_multiplier>
    <max_Timestep>       100         </max_Timestep>
    <end_on_max_time_exactly>true    </end_on_max_time_exactly>
</Time>
\end{Verbatim}
%
%__________________________________
\subsection{Data Archiver} \label{Sec:DataArchiver}
- variable labels\\
- checkpointing \\
- different options for specifying the output frequency\\

The Data Archiver section specifies the directory name where data will
be stored and what variables will be saved and how often data is saved
and how frequently the simulation is checkpointed.

The \tt <filebase> \normalfont tag is used to specify the directory
name and by convention, the .uda suffix is attached denoting the
'uintah data archive'.


Data can be saved based on a frequency setting that is either time
based on by the number of timesteps taken. 

The \tt <outputInterval> \normalfont is the time based tag which takes
a floating point number whereas the \tt <outputTimestepInterval>
\normalfont is the frequency based tag which takes an integer number.


Each simulation component specifies variables with label names that
can be specified for data output.  By convention, particle data is
denoted by \tt p. \normalfont followed by a particular variable name
such as mass, velocity, stress, etc.  Whereas for grid data, the
convention is to use the \tt g. \normalfont followed by the variable
name, such as mass, stress, velocity, etc.  Within the DataArchiver
section, variables are specified with the following format:

\begin{verbatim}[fontsize=\footnotesize]

   <save label = "p.mass" />
   <save label = "g.mass" />

\end{verbatim}


Checkpointing information can be created that provides a mechanism for
restarting a simulation at a later point in time.  The \tt
<checkpoint> \normalfont tag with the \tt cycle \normalfont and \tt
interval \normalfont attributes describe how many copies of checkpoint
data is stored (cycle)  and how often it is generated (interval). 

As an example of checkpoint data that has two timesteps worth of
checkpoint data that is created every .01 seconds of simulation time
is shown below:

\begin{verbatim}[fontsize=\footnotesize]

<checkpoint cycle = "2" interval = "0.01"/>

\end{verbatim}

%
%__________________________________
\subsection{Geometry objects} \label{Sec:GeometryObjects}
- different objects available and how to specify them\\
- what is res \\
- operators, union, difference\\
- example of combining several geom\_objects\\

%__________________________________
\subsection{Boundary conditions}
- describe how to have a jet in the floor of the domain.
%
%__________________________________
\subsection{Grid specification} \label{Sec:Grid}
Explain how a grid is specified and what these tags mean

\begin{Verbatim}[fontsize=\footnotesize]
<Level>
    <Box label="1">
       <lower>        [0,0,0]          </lower>
       <upper>        [5,5,5]          </upper>
       <extraCells>   [1,1,1]          </extraCells>
       <patches>      [1,1,1]          </patches>
    </Box>
    <spacing>         [0.5,0.5,0.5]    </spacing>
</Level>
 \end{Verbatim}
%
%__________________________________
\subsection{Adapative Mesh Refinement}
- need to discuss the input options for the different regridders.\\
- How is a cell flagged as needing to be refined
%
%__________________________________
\subsection{load Balancer}
- to be filled in

%__________________________________
\subsection{UDA}

\subsubsection{UDA Directory Structure}

The UDA is a file/directory structure used to save Uintah simulation
data.  For the most part, the user need not concern him or herself
with the UDA layout, but it is a good idea to have a general feeling
for how the data is stored on disk...

%\subsubsubsection{UDA Naming}

Every time a simulation (sus) is run, a new UDA is created.  Sus uses
the <filebase> tag in the simulation input
(FIXME: link to [[Documentation/UsersGuide Input\_Files|.ups]]) file to name the UDA
directory (appending a version number).  If an UDA of that name
already exists, the next version number is used.  Additionally, a
symbolic link named ``disks.uda'' (is updated to and) will point to
the newest version of this simulations UDA.  Eg:

disks.uda.000
disks.uda.001
disks.uda.001 <- disks.uda

%\subsubsubsection{UDA Files}

Each UDA consists of a number of top level files, a checkpoints
subdirectory, and subdirectories for each saved timestep.  These files
include:

- \tt.dat\normalfont files contain global information about the simulation
(each line in the .dat files contains: simulation\_time value).
- The \tt checkpoints\normalfont directory contains a limited number of time
step data subdirectories that contain a complete snapshot of the
simulation (allowing for the simulation to be restarted from that
time).
- \tt input.xml\normalfont contains the original problem specification (the
.ups file).
- \tt index.xml\normalfont contains information on the actual simulation run.
- \tt t0000 FIXME number sign\normalfont contains data saved for that specific time step.  The
data saved is specified in .ups file and may be a very limited subset
of the full simulation data.

Example UDA file list:

CenterOfMassPosition.dat
CenterOfMassVelocity.dat
KineticEnergy.dat
StrainEnergy.dat
TotalMass.dat
checkpoints
index.xml
input.xml
t00001
t00057

%\subsubsection{Known Issues} 

Occasionally, due (most likely) to file system issues on large
clusters, some of the files in the UDA have been found to be corrupted
or nonexistent.  (There is error checking in the code to try to
prevent this.  We believe that either the OS/File system is
incorreclty returning error codes, or, more likely, that the files are
corrupted (due to file system issues) after the simulation is done.

%\subsubsection{Restarting} 

The sus executable provides a mechanism for checkpointing the code and
then restarting the ongoing simulation from a given checkpoint. 



%__________________________________
\subsection{Visualization tools}

Visualization of Uintah data is currently possible using any of three
software packages.  These are SCIRun, VisIt and Manta.  Of these, SCIRun is
no longer supported, although legacy versions will continue to work.  The
VisIt package from LLNL is general purpose visualization software that offers
all of the usual capabilities for rendering scientific data.  It is still
developed and maintained by LLNL staff, and its interface to Uintah data is
supported by the Uintah team.  Manta offers volume rendering and particle
visualizaton based on parallel (shared memory) ray tracing techniques.
While the capabilities of Manta are more limited, it is a fast way to
interactively interrogate reasonably large datasets, provided the user has
access to a reasonable shared memory resource, (e.g. an 8 core desktop system).

\subsubsection{VisIt}

\subsubsection{Manta}

%__________________________________
\subsection{Data Extraction Tools}

Uintah offers a number of tools for accessing data stored in Uintah Data
Archives (``UDAs").  Because the format of Uintah data is specific to the 
framework, these tools allow a user to quickly extract data, which can then
either be postprocessed within that tool (simple modification of the source
code may be necessary), postprocessed with external software such as
Matlab or Octave, or simply plotted with, e.g. gnuplot.  These tools
are described below.

\subsubsection{puda}

\subsubsection{partextract}

\subsubsection{lineextract}

\subsubsection{timeextract}

\subsubsection{compare\_uda}

%__________________________________
\subsubsection{plotting tools}
- plotStats\\
- plotRegridder \\
- plotCPU\_usage \\
- plotComponents

%__________________________________
\subsection{Code}
-explain the basic directory structure of src
\begin{Verbatim}[fontsize=\footnotesize]
|-- CCA
|-- Components
|   |-- Angio
|   |-- Arches
|   |-- DataArchiver
|   |-- Examples
|   |-- ICE
|   |-- LoadBalancers
|   |-- MPM
|   |-- MPMArches
|   |-- MPMICE
|   |-- Models
|   |-- OnTheFlyAnalysis
|   |-- Parent
|   |-- PatchCombiner
|   |-- ProblemSpecification
|   |-- Regridder
|   |-- Schedulers
|   |-- SimulationController
|   |-- Solvers
|   |-- SpatialOps
|   `-- SwitchingCriteria
|-- Ports
|-- Core
|-- R_Tester
|-- StandAlone
|-- Teem
|-- VisIt
|-- build_scripts
|-- include
|-- orderAccuracy
|-- scripts
|-- tau
|-- testprograms
`-- tools
\end{Verbatim}
