/*
 * This file was automatically generated by SCC - do NOT edit!
 * You should edit Mailbox.scc instead 
 */

#ifndef SCI_THREAD_MAILBOX_H
#define SCI_THREAD_MAILBOX_H 1

/*
 * A thread-safe, fixed-length FIFO queue which allows multiple
 * concurrent senders and receivers.  Multiple threads send <b>Item</b>s
 * to the mailbox, and multiple thread may receive <b>Item</b>s from the
 * mailbox.  Items are typically pointers to a message structure.
 */

#include "Thread.h"
#include "Semaphore.h"
#include "Mutex.h"
#include "ConditionVariable.h"

template<class Item> class Mailbox {
    Mutex mutex;
    Item* ring_buffer;
    int head;
    int len;
    int max;
    ConditionVariable empty;
    ConditionVariable full;
    Semaphore rendezvous;
    int send_wait;
    int recv_wait;
    const char* name;
    inline int ringnext(int inc) ;
public:
    Mailbox(const char* name, int size)
	;
    ~Mailbox() ;
    void send(Item msg) ;
    bool try_send(Item msg);
    Item receive() ;
    bool try_receive(Item& item) ;
    int size() const ;
    int nitems() const ;
};

template<class Item> inline int Mailbox< Item>::ringnext(int inc) {
    return max==0?0:((head+inc)%max);
}

template<class Item> Mailbox< Item>::Mailbox(const char* name, int size)
	: name(name), mutex("Mailbox lock"),
      empty("Mailbox empty condition"), full("Mailbox full condition"),
      rendezvous("Mailbox rendezvous semaphore", 0)
{
    ring_buffer=new Item[size==0?1:size];
    head=0;
    len=0;
    send_wait=0;
    recv_wait=0;
    max=size;
}

template<class Item> Mailbox< Item>::~Mailbox() {
    delete[] ring_buffer;
}

template<class Item> void Mailbox< Item>::send(Item msg) {
    int s=Thread::couldBlock(name);
    mutex.lock();
    // See if the message buffer is full...
    int rmax=max==0?1:max;
    while(len == rmax){
        send_wait++;
        full.wait(mutex);
        send_wait--;
    }
    ring_buffer[ringnext(len)]=msg;
    len++;
    if(recv_wait)
        empty.cond_signal();
    mutex.unlock();
    if(max==0)
        rendezvous.down();
    Thread::couldBlock(s);
}

template<class Item> bool Mailbox< Item>::try_send(Item msg){
    mutex.lock();
    // See if the message buffer is full...
    int rmax=max==0?1:max;
    if(len == rmax){
        mutex.unlock();
        return false;
    }
    if(max == 0 && recv_wait==0){
        // No receivers waiting, so rendezvous will fail. Return now.
        mutex.unlock();
        return false;
    }

    ring_buffer[ringnext(len)]=msg;
    len++;
    if(recv_wait)
        empty.cond_signal();
    mutex.unlock();
    if(max==0)
        rendezvous.down();  // Won't block for long, since a receiver
                            // will wake us up
    return true;
}

template<class Item> Item Mailbox< Item>::receive() {
    int s=Thread::couldBlock(name);
    mutex.lock();
    while(len == 0){
        recv_wait++;
        empty.wait(mutex);
        recv_wait--;
    }
    Item val=ring_buffer[head];
    head=ringnext(1);
    len--;
    if(send_wait)
        full.cond_signal();
    mutex.unlock();
    if(max==0)
        rendezvous.up();
    Thread::couldBlock(s);
    return val;
}

template<class Item> bool Mailbox< Item>::try_receive(Item& item) {
    mutex.lock();
    if(len == 0){
        mutex.unlock();
        return false;
    }
    item=ring_buffer[head];
    head=ringnext(1);
    len--;
    if(send_wait)
        full.cond_signal();
    mutex.unlock();
    if(max==0)
        rendezvous.up();
    return true;
}

template<class Item> int Mailbox< Item>::size() const {
    return max;
}

template<class Item> int Mailbox< Item>::nitems() const {
    return len;
}

#endif
