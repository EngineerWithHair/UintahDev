/*
 * This file was automatically generated by SCC - do NOT edit!
 * You should edit Thread.scc instead 
 */

#ifndef SCI_THREAD_THREAD_H
#define SCI_THREAD_THREAD_H 1


class ThreadGroup;
class ThreadError;
struct ThreadEvent;
class ThreadTopology;
class ThreadListener;

#include "ParallelBase.h"
#include "Runnable.h"

#include <stdio.h>


typedef long long SysClock;


struct Thread_private;
class Thread {
    friend class Mutex;
    friend class Semaphore;
    friend class Barrier;
    friend class PoolMutex;
    Thread(const Thread&);
    ~Thread() ;
    bool daemon;
    bool detached;
    Runnable* runner;
    char* threadname;
    Thread_private* priv;
    ThreadGroup* group;
    int cpu;
    int priority;
    ThreadError* abort_handler;
    void os_start(bool stopped);
    static void initialize();
    Thread(ThreadGroup* g, char* name) ;
	    friend class Runnable;
    static int nlisteners;
    static ThreadListener** listeners;
    friend void Thread_send_event(Thread* t, ThreadEvent);
    static void event(Thread* t, ThreadEvent event) ;
    friend void Thread_run(Thread*);
    friend void Thread_shutdown(Thread*);
    void run_body();
    class ParallelHelper : public Runnable {
	const ParallelBase* helper;
	int proc;
    public:
	ParallelHelper(const ParallelBase* helper, int proc)
	    : helper(helper), proc(proc) {}
	virtual ~ParallelHelper() {}
	virtual void run() {
	    ParallelBase* cheat=(ParallelBase*)helper;
	    cheat->run(proc);
	}
    };
    static void check_exit();
    friend class Profiler;
    static void profile(FILE* in, FILE* out);
public:
    Thread(Runnable* runner, const char* name, ThreadGroup* group=0, bool stopped=false)
      ;
    ThreadGroup* threadGroup() ;
    void setDaemon(bool to=true) ;
    void setPriority(int priority);
    int getPriority() const ;
    bool isDaemon() const ;
    void detach();
    bool isDetached() const ;
    static void exitAll(int code);
    static void error(char* error) ;
    static Thread* currentThread();
    void stop();
    void resume();
    void join();
    void alert(int code=0);
    const char* threadName() const ;
    static int numProcessors();
    void migrate(int proc);
    Thread_private* getPrivate() const ;
    enum Topology {
	Linear,
	Ring,
	Square,
	Cube
    };
    static ThreadGroup* parallel(const ParallelBase& helper, int nthreads,
				 bool block=false, ThreadGroup* threadGroup=0) ;
    static ThreadGroup* parallel(const ParallelBase& helper, int nthreads,
				 Topology topologyHint,
				 bool block=false,
				 ThreadGroup* threadGroup=0);
    static ThreadGroup* parallel(const ParallelBase& helper,
				 const ThreadTopology& topologyHint,
				 bool block=false,
				 ThreadGroup* threadGroup=0);
    static SysClock currentTicks();
    static double currentSeconds();
    static double ticksPerSecond();
    static double secondsPerTick();
    static void waitUntil(SysClock ticks);
    static void waitUntil(double seconds);
    static void waitFor(SysClock ticks);
    static void waitFor(double seconds);
    static void niceAbort() ;
    static int couldBlock(const char* why);
    static void couldBlock(int restore);

    static void roundRobinPlacement( void *mem, size_t len );
};

#endif
