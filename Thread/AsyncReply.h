/*
 * This file was automatically generated by SCC - do NOT edit!
 * You should edit AsyncReply.scc instead 
 */

#ifndef SCI_THREAD_ASYNCREPLY_H
#define SCI_THREAD_ASYNCREPLY_H 1

/*
 * Creates a single slot for some return value.  The <i>wait</i> method
 * waits for a value to be sent from another thread via the <i>reply</i>
 * method.  This is typically used to provide a simple means of returning
 * data from a server thread.  An <b>AsyncReply</b> object is created on the
 * stack, and some request is sent (usually via a <b>Mailbox</b>) to a server
 * thread.  Then the thread will block in <i>wait</i> until the server thread
 * receives the message and responds using <i>reply</i>.
 *
 * <p><b>AsyncReply</b> is a one-shot wait/reply pair - a new <b>AsyncReply</b>
 * object must be created for each reply.  Only a single thread should
 * call <i>wait</i> and a single thread shuold call <i>reply</i>.
 */

#include "Thread.h"
#include "Semaphore.h"

template<class Item> class AsyncReply {
    const char* name;
    Item value;
    Semaphore sema;
public:
    AsyncReply(const char* name);
    ~AsyncReply() ;
    Item wait() ;
    void reply(Item reply) ;
};

template<class Item> AsyncReply< Item>::AsyncReply(const char* name): name(name), sema("AsyncReply semaphore", 0) {}

template<class Item> AsyncReply< Item>::~AsyncReply() {}

template<class Item> Item AsyncReply< Item>::wait() {
    int s=Thread::couldBlock(name);
    sema.down();
    Thread::couldBlock(s);
    return value;
}

template<class Item> void AsyncReply< Item>::reply(Item reply) {
    value=reply;
    sema.up();
}

#endif
